# -*- coding: utf-8 -*-
#
# Copyright 2012-2013 Narantech Inc. All rights reserved.
#  __    _ _______ ______   _______ __    _ _______ _______ _______ __   __
# |  |  | |   _   |    _ | |   _   |  |  | |       |       |       |  | |  |
# |   |_| |  |_|  |   | || |  |_|  |   |_| |_     _|    ___|       |  |_|  |
# |       |       |   |_||_|       |       | |   | |   |___|       |       |
# |  _    |       |    __  |       |  _    | |   | |    ___|      _|       |
# | | |   |   _   |   |  | |   _   | | |   | |   | |   |___|     |_|   _   |
# |_|  |__|__| |__|___|  |_|__| |__|_|  |__| |___| |_______|_______|__| |__|

"""The engine system module.
"""

import os
import locale
import logging
import psutil
import subprocess

import engine.aengel
from engine.isc import endpoint
from engine.isc import PRIVILEGED
from adt.concurrency import Lazy
import engine.runtime
from engine.runtime import ROOT_PATH
from engine.runtime import LOG_PATH
from engine.runtime import MAIN_LOG_FILENAME


__DATA__ = Lazy()
__DATA__.add_initializer('cpu_clock_speeds', lambda: _cpu_clock_speeds())
__DATA__.add_initializer('serial_number', lambda: _serial_number())
__SAFE_FREE_SIZE__ = 1073741824  # 1GB


@endpoint(elevated=True, protection=PRIVILEGED)
def reboot():
  logging.info("REBOOT requested.")
  engine.aengel.reboot()


@endpoint(namespace='system', elevated=True, protection=PRIVILEGED)
def restart():
  logging.info("restart requested.")
  engine.aengel.restart()


@endpoint(elevated=True, protection=PRIVILEGED)
def reset(factory=False):
  pass


@endpoint()
def get_timezone():
  """Get timezone for linux base timezone
  return [continent]/[city]
  e.g : Asia/Seoul
  """
  # TODO : default get timezone if /etc/timezone not exist
  if os.path.exists(ROOT_PATH + 'etc/timezone'):
    with open(ROOT_PATH + 'etc/timezone') as rf:
      timezone = rf.read().split()[0]
    return timezone
  else:
    raise Exception("/etc/timezone is not exist")


@endpoint(elevated=True, protection=PRIVILEGED)
def set_timezone(timezone):
  """Set timezone.
  parameter value must be [continent]/[city]
  e.g : Asia/Seoul
  set link or copy /etc/localtime
  change /etc/timezone
  must be reboot
  """
  if os.path.exists(os.path.join(ROOT_PATH + 'usr/share/zoneinfo', timezone)):
    # create symbolic link localtime and record the timezone
    t = 'ln -sf %susr/share/zoneinfo/%s %setc/localtime; \
        echo %s > %setc/timezone' % (ROOT_PATH, timezone, ROOT_PATH, timezone,
                                     ROOT_PATH)
    engine.aengel.execute_cmd(t)
  else:
    raise Exception("%s is not exist." % timezone)


@endpoint()
def get_language():
  """Get current locale for linux
  return e.g: ko_KR
  """
  language = locale.getdefaultlocale()
  if language:
    return language[0]
  else:
    raise Exception("Failed to get language.")


@endpoint(elevated=True, protection=PRIVILEGED)
def set_language(language):
  """Set locale for linux
  change /etc/default/locale and used LANG
  must be reboot
  """
  if os.path.exists(os.path.join(ROOT_PATH + 'usr/share/i18n/locales',
                                 language)):
    # TODO: only change lang other set C
    locale_content = '''# File generated by set_language from clique\n'''
    '''LANG=%s.utf8''' % language
    engine.aengel.execute_cmd("echo %s > %s" % (
        locale_content, ROOT_PATH + 'etc/default/locale'))
  else:
    raise Exception("Language %s not supported." % language)


@endpoint()
def get_cpu_temperature():
  """The current CPU temperature in celcius degree.
  """
  try:
    temp_info_path = ROOT_PATH + '''sys/class/thermal/thermal_zone0/temp'''
    with open(temp_info_path, 'r') as f:
      temp = f.read()
    return int(temp) / 1000
  except:
    logging.warn("Failed to read the temperature data.", exc_info=True)
  return 0.0


@endpoint()
def get_cpu_clock_speeds():
  """The current CPU clock speeds in Mhz for all cores in list.
  """
  return __DATA__.cpu_clock_speeds


def _cpu_clock_speeds():
  """CPU clock speeds initializer.
  """
  try:
    speed_info_path = ROOT_PATH + 'sys/devices/system/cpu/cpu0/cpufreq'
    '/scaling_cur_freq'
    with open(speed_info_path, 'r') as f:
      speed = f.read()
    return [int(speed) / 1000]
  except:
    logging.warn("Failed to read the clock speed data.", exc_info=True)
  return []


@endpoint()
def get_cpu_percentage(pid=None, recursive=True):
  """ Return a float representing the current system-wide CPU utilization
  as a percentage.

  Returns:
    Returns a list of floats representing the utilization as a percentage
    for each CPU. First element of the list refers to first CPU,
    second element to second CPU and so on. The order of the list is
    consistent across calls.

      [(CPU1_percentage), (CPU2_percentage), ..]
  """
  return psutil.cpu_percent(interval=0, percpu=True)


@endpoint()
def get_main_memory(pid=None, recursive=True):
  """The main memory size (RS used, VM used, total) in MBs.

  Args:
    If pid is None, get memory data of machine

  Returns:
    ((phy_total, (phy_usage), (virt_total), (virt_usage))

  """
  if not pid:
    phymem = psutil.phymem_usage()
    virtmem = psutil.virtmem_usage()
    return (float(phymem.total), float(phymem.used), float(virtmem.total),
            float(virtmem.used))


@endpoint()
def get_disk_usage():
  """The disk size in Bs.

  Returns:
    (total size, used size)
  """
  st = os.statvfs('/')
  total = st.f_blocks * st.f_frsize
  used = (st.f_blocks - st.f_bfree) * st.f_frsize
  return (total, used + __SAFE_FREE_SIZE__)


@endpoint()
def get_gpu_memory():
  """The GPU memory size in MBs.
  """
  pass


@endpoint()
def get_uptime():
  """Gets the system uptime in seconds.
  """
  pass


@endpoint(elevated=True)
def get_serial_number():
  """The system serial nubmer.
  """
  return __DATA__.serial_number


def _serial_number():
  """Initializer for the serial number.
  """
  # Read from the CPU info
  try:
    cpu_info_path = ROOT_PATH + 'proc/cpuinfo'
    with open(cpu_info_path) as f:
      for line in f:
        l = line.lower()
        if l.startswith('serial'):
          val = l.split(':')[1].strip()
          import hashlib
          return hashlib.md5(val).hexdigest()

    logging.warn("CPU has no serial number.")
  except:
    logging.warn("Failed to read the serial number.", exc_info=True)
  return None


@endpoint()
def retrieve_logs(appname=None, last_nbytes='1k'):
  """Outputs the last n bytes of the log file.
  If appname is specified, it outputs the log of the app.
  `last_nbytes` is defined in string (unit character at the end is accepted).
  """
  context = engine.runtime.context()
  log_path = appname and \
      context.get_app_root_dir(appname) + LOG_PATH + '/' + appname or \
      LOG_PATH + '/' + MAIN_LOG_FILENAME
  return subprocess.check_output('tail -c %s %s' % (last_nbytes, log_path),
                                 shell=True)


@endpoint()
def pair_audio_device(mac):
  """FIXME: move this to media.py module later on.
  """
  try:
    subprocess.check_call('bluez-simple-agent hci0 %s' % mac, shell=True)
  except:
    logging.exception("Error in bluez-simple-agent.")
  try:
    subprocess.check_call('bluez-test-audio connect %s' % mac, shell=True)
  except:
    logging.exception("Error in bluez-test-audio.")
  try:
    subprocess.check_call('bluez-test-device trusted %s yes' % mac, shell=True)
  except:
    logging.exception("Error in bluez-test-device trusted.")
  logging.info("Successfully connected the audio device : %s", mac)
